# HTTP 웹 기본 지식 강의 정리
<br>

## 인터넷 네트워크

**IP (Internet Protocol) : 인터넷 프로토콜**
<br><br>
먼 곳에 있는 사람과 통신을 하려면 어떻게 해야 할까? 이를 위해 사람들은 개별 노드 (PC) 마다 IP라는 고유 식별 ID를 부여해서 다른 PC와 통신하려 할 때 내 IP주소와 보낼 곳의 IP주소 그리고 보낼 내용을 패킷에 담아 보낸다. 이제 이 패킷이 여러 노드를 걸쳐 목적지의 IP주소로 보내지게 되는데 이것만으로는 해결할 수 없는 문제가 있다. 

1. 비연결성 
    
    패킷을 받을 대상이 없거나 대상이 서비스 불능 상태여도 패킷을 전송할 수도 있다.
    

1. 비신뢰성
    
    패킷을 보내는 과정 중 어떠한 문제가 생겨 패킷이 소실 됐을 상황을 해결할 수 없다. 또, 크기가 큰 패킷을 보낼 때는 여러 개의 패킷으로 나누어서 보내게 되는데 이 순서를 보장하지 않고 보내게 되면 원하는 내용을 정확하게 전달할 수 없다.
    

1. 보낼 곳의 서버 통신 애플리케이션이 둘 이상일 경우
    
    이 경우에 어떤 애플리케이션과 통신할 지 알 수 없다.

그러므로 상기의 문제를 해결할 수 있는 방법이 필요했다.
<br><br>
**TCP (Transmission Control Protocol) : 전송 제어 프로토콜**
<br><br>
위의 IP의 한계점을 개선하기 위해 만들어진 4계층 프로토콜. 전송할 데이터에 출발지, 목적지 Port 정보, 전송 제어, 순서, 검증 정보들을 감싸서 IP 계층으로 넘겨 준다. 이로 인해 IP의 한계점을 개선할 수 있다.

1. 3 way handshake
    
    TCP는 대상 PC와의 확실한 연결을 보장하기 위해 3 way handshake 방법을 사용한다. 클라이언트가 서버에 접속을 요청하는 SYN를 보내고(1), 이걸 받은 서버는 이 요청을 잘 받았다는 ACK와 함께 서버도 클라이언트에 접속을 요청하는 SYN을 같이 보내며(2), 이걸 받은 클라이언트도 잘 받았다는 ACK를 서버에 보낸다(3). 이 과정이 완료된 후에 데이터 전송을 할 수 있다. 이 방법으로 IP의 비연결성 문제를 해결할 수 있다. 이 때의 연결은 물리적인 연결이 아니라 , Peer to Peer의 논리적 연결이다.
    
2. 데이터 전달 보증
    
    서버가 클라이언트로부터 데이터를 잘 받았을 때, 받았다고 끝나는 것이 아니라 잘 받았다고 회신해준다. 이로 인해 IP의 비신뢰성 문제를 해결한다.
    

1. 순서 보장
    
    3개의 패킷을 1,2,3의 순서로 보냈다고 했을 때, 만약 1,3,2의 순서로 받았다면 3 이후의 패킷을 모두 버리고 2부터 다시 보내라고 요청한다. 이로 인해 IP의 순서 비신뢰성을 해결할 수 있다.
    

이것들은 모두 TCP에 담긴 전송 제어, 순서, 검증 정보들이 있기 때문에 가능하고 이러한 점 덕분에 TCP는 신뢰 가능한 프로토콜이라 불리며 현재 90% 이상의 점유율을 가지고 있다.
<br><br>
**UDP (User Data Protocol) : 사용자 데이터그램 프로토콜**
<br><br>
TCP와 달리 UDP는 별다른 기능을 지원하지 않고 Port와 체크섬 정보정도만 담아 주기 때문에 전달 보증이라든지 순서 보장을 하지 않는다. 대신에 사전 작업이 거의 없기 때문에 단순하고 빠르다는 장점이 있다. 그리고 별다른 기능이 없기에 애플리케이션 단계에서 추가 작업을 편하게 할 수 있다는 점 때문에 최근에 많이 사용하려는 추세이다.
<br><br>

**Port : 포트**
<br><br>
같은 IP 내에서 프로세스를 구분하는 식별 번호. 0 ~ 1023 까지는 사용하지 않는 것이 좋음
<br><br>
**DNS (Domain Name System) : 도메인 이름 시스템** 
<br><br>
IP는 기억하기 어렵고 바뀌기도 쉽다. 그래서 쉽게 알 수 있는 도메인 이름을 IP랑 매칭시켜 접근을 용이하게 할 수 있다. IP가 변경되도 도메인 이름이 바뀌지 않기 때문에 제공자만 IP를 교체하면 된다.
<br><br>

# URI와 웹 브라우저 요청 흐름

URI (Uniform Resource Identifier) : 통합 자원 식별자

Uniform : 리소스를 식별하는 통일된 방식

Resource : 자원, URI로 식별할 수 있는 모든것

Identifier : 다른 항목과 구분하는데 필요한 정보

URL(Resource Locator) : 리소스가 있는 위치를 지정

URN(Resource Name) : 리소스에 이름을 부여 ← 이름만으로 실제 리소스를 찾는 방법인 보편적 x

URI ← URL + URN

** URN은 거의 의미가 없으므로 URI와 URL은 거의 비슷하게 사용
<br><br>
**https://www.google.com/search?q=hello&hl=ko 를 브라우저 주소 창에 입력했을 때 벌어지는 일**

1. DNS 서버에서 www.google.com 에 해당하는 IP를 찾고 포트를 파악한다 → HTTPS가 쓰는 443
2. 1번에서 찾은 정보를 바탕으로 HTTP 요청 메시지를 작성한다.
    
    GET /search?q=hello&hl=ko HTTP/1.1
   <br><br>
    Host: www.google.com
    
4. socket 라이브러리가 TCP/IP 연결을 수립하고 위의 HTTP 요청 메시지를  OS 단에 존재하는 TCP/IP 계층에 전달한다.
5. TCP/IP 계층에서 TCP/IP 패킷을 생성한다. 여기서 전달한 데이터가 HTTP 요청 메시지이다.
6. TCP/IP 패킷이 목적지에 전달되고 서버에서 패킷을 뜯어 전달된 HTTP 요청 메시지를 확인한다.
7. 서버에서 HTTP 응답 메시지를 작성한다.
    
    HTTP/1.1 200 OK
   <br>
    Content-Type: text/html;charset=UTF-8
   <br>
    Content-Length: 3423
   <br>
    html
   <br>
    body.../body
   <br>
    /html
    <br>
9. 이 응답 메시지를 마찬가지로 TCP/IP 패킷으로 싸서 클라이언트로 전송한다.
10. 클라이언트에서도 패킷을 뜯어 응답 메시지를 확인하고 브라우저는 응답 메시지를 렌더링한다.
<br><br>
# HTTP의 모든 것

**HTTP (Hyper Text Transfer Protocol)**

: HTTP 메세지에 모든 종류의 데이터를 담아 전송할 수 있다.

HTTP 1.1을 가장 많이 사용하고 거의 모든 기능이 이 버전에 있다. 그 후는 성능 개선

**특징**

1. 클라이언트 서버 구조
    - Request Response 구조
    - 서버는 데이터 및 로직 관련, 클라이언트 UI 관련으로 나누어 독립적이고 집중적으로 개발

 

1. 무상태 프로토콜 (Stateless)
    - 서버가 클라이언트의 상태를 보존하지 않음
    - Stateful : 중간에 서버가 바뀌면 안된다 → 바뀔 때 다른 서버에게 알려줘야 함
        
        Stateless : 중간에 서버가 바뀌어도 된다 → 응답할 서버를 무한히 증설 가능
        
    - 중간에 서버 하나가 장애가 나도 다른 서버로 쉽게 바꿀 수 있다 → 수평 확장에 유리
    - 모든 것을 Stateless 하게 할 순 없다 ex) 로그인 → 쿠키와 세션을 사용해서 보완

1. 비연결성
    - 기본적으로 연결을 유지하지 않는 모델
    - 수 천 명이 서비스를 사용해도 실제 서버에서 동시 처리하는 요청은 수 십 개 이하로 작음
    - 3 way handshake 시간이 오버 헤드로 작용, 매번 이미지같은 자원이 함께 다운로드 됨
        
        → 지속 연결로 문제 해결
        

1. HTTP 메시지
    - 시작 라인 → 헤더 → 공백 → 바디의 구조
<br><br>
# HTTP API

**API URI 설계**

 API URI를 설계할 때 가장 중요한 것은 리소스를 식별하는 것이다. 예를 들어 회원을 조회하는 API 경로를 

member/read-member-by-id 이런 식으로 설계하는 것은 바람직하지 않다. 자원에 대한 행동 자체를 경로에 넣도록 설계하는 것은 좋지 않은 설계 방법이란 얘기이다. 그러므로 올바른 설계는 members/{id} 처럼 리소스에 대한 것만 나와있어야 한다. 그렇다면 이 API가 무슨 동작을 할 지를 어떻게 구별할 수 있을까? 이 때 필요한 것이  API 메소드이다. 주요 HTTP API 메서드를 나열하면 다음과 같다.

1. GET : 리소스 조회
2. POST : 요청 데이터 처리, 주로 등록에 사용
3. PUT : 리소스를 대체, 해당 리소스가 없으면 생서
4. PATCH : 리소스 부분 변경
5. DELETE : 리소스 삭제

하나 하나 자세히 살펴보자

— GET

- 리소스 조회에 사용, 전달하고 싶은 데이터는 query 파라미터 또는 스트링을 통해서 전달
- 메시지 바디를 사용해서 전달은 가능하지만 지원하는 곳이 많지 않아 권장하지 않음

— POST

- 요청 데이터를 처리하며 메시지 바드를 통해 서버로 요청 데이터를 전닳
- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행, 애매하면 POST
- 주로 신규 리소스 등록, 프로세스 처리에 사용
- api 설계에 동작을 넣지 않는 것이 국룰이지만 이것만으로 모든 문제를 해결할 수 없기 때문에 예외적으로 /orders/{orderId}/start-delivery 처럼 설계하고 이 결과 리소스가 생성되지 않고 프로세스만 처리되는 경우도 생길 수 있다. 이를  컨트롤 URI라고 부른다

— PUT

- 리소스를 대체 없으면 생성 ← 덮어쓰기
- POST와 달리 클라이언트가  리소스의 위치를 알고  URI를 지정함
- 리소스를 완전히 지우고 다시 만드는 것과 같은 동작을 하기 때문에 주의가 필요
    
    → PATCH 메서드를 만들어 부분 변경할 수 있게 함
    

— DELETE
- 해당 리소스 제거
<br><br>

**HTTP 메서드의 속성**

— 안전

- 호출해도 리소스가 변경되지 않음 → 해당 리소스에 대한 것만 고려

— 멱등

- 한 번 호출하든 여러 번 호출하든 결과가 같은 것
    
    GET :  여러 번 호출해도 같은 결과 조회 → 멱등
    
    PUT : 리소스를 대체 하기 때문에 여러 번해도 같은 결과 → 멱등
    
    DELETE : 같은 요청을 여러 번 해도 삭제된 결과는 같음 → 멱등
    
    POST : 여러 번 호출하면 결과가 바뀜 → 멱등x
    
- 외부 요인으로 중간에 리소스가 바뀌는 것은 고려하지 않음

— 캐시가능여부

- 응답 결과 리소스를 캐시해서 사용할 수 있는 지
- GET, HEAD, POST, PATCH 등이 캐시 가능하지만 POST, PATCH는 본문 내용까지 캐시 키로 고려해야 해 구현이 쉽지 않아 주로 GET, HEAD만 캐시로 사용
<br><br>
# HTTP 메서드 활용

 **클라이언트에서 서버로 데이터 전송**

전달방식

1. 쿼리 파라미터를 통해 :  GET의 정렬  필터
2. 메시지 바디를 통해 :  POST, PUT, PATCH

전송이 필요한 4가지 상황

1. 정적 데이터 조회 : 이미지, 정적 텍스트 문서
2. 동적 데이터 조회 : 검색, 게시판 목록에서 정렬 필터
3. HTML Form을 통해 전송
4. HTTP API를 통한 데이터 전송 : 서버 to 서버, 앱 클라이언트(Android), 웹 클라이언트(Ajax)
<br><br>
# HTTP 메서드 활용 예시

— 문서 ( Document)

- 단일 개념 ex) 파일 하나, 객체 인스턴스, 데이터베이스 row
- /members/100, /files/star.jpg : GET

— 컬렉션 (Collection)

- 서버가 관리하는 리소스의 디렉터리
- 서바가 리소스의 URI를 생성하고 관리
- /members : POST

— 스토어 (store)

- 클라이언트가 관리하는 자원 저장소
- 클라이언트가 리소스의 URI를 알고 관리
- /files : PUT

— 컨트롤러 (controller), 컨트롤 URI

- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
- 동사를 직접 사용
- /members/{id}/delete : POST
<br><br>
# HTTP 상태코드

**2xx : Successful**

1. 200 OK : 요청 성공
2. 201 Created : 요청 성공해서 새 리소스 생성
3. 202 Accepted : 요청이 접수되었으나 처리가 완료되지 않음
4. 204 No Content : 요청을 성공적으로 수행했지만 응답 본문에 보낼 데이터가 없음
<br><br>

**3xx : Redirect**

리다이렉션 : 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동 이동

영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동

1. 301 Moved Permanently : 리다이렉트 시 요청 메서드가 GET으로 변하고 본문이 제거
2. 308 Permanent Redirect : 301과 동일, But 요청 메서드와 본문 유지

** 308은 거의 사용할 일이 없음

일시 리다이렉션 : 일시적인 변경 ex) 주문 완료 후 주문 내역 화면으로 이동, PRG

1. 302 Found : 리다이렉트 시 요청 메서드가 GET으로 변하고 본문이 제거
2. 307 Temporary Redirect : 302와 동일, 요청 메서드와 본문 유지
3. 303 See Other : 302와 동일, 리다이렉트 시 요청 메서드가 GET으로 변경

** PRG : POST/Redirect/GET

POST에서 새로고침하면 다시 POST해서 주문이나 등록이 중복될 수 있다.

→ POST 요청하면 일시적 리다이렉션해서 GET 요청으로 변경해서 중복 방지

특수 리다이렉션 : 결과 대신 캐시를 사용

1. 304 Not Modified
    - 캐시를 목적으로 새용
    - 클라이언트에서 리소스가 수정되지 않았음을 알려줌 → 로컬 PC에 저장된 캐시를 재사용
    - 304 응답은 응답에 메시지 바디를 포함하면 안 됨 ← 로컬 캐시 사용
    - 조건부 GET, HEAD 요청 시 사용
    
<br><br>
**4xx : Client Error**

: 오류의 원인이 클라이언트에 있음 → 재시도가 무조건 실패함
<br><br>
1. 400 Bad Request : 잘못된 요청으로 서버가 처리할 수 없음 ex) 파라미터 에러, API 스펙 안 맞음
2. 401 Unauthorized : 인증이 되지 않음, 응답에 인증 방법을 설명함

** 인증 Authentication : 본인이 누구인지 확인

     인가 Authorization : 권한부여

1. 403 Forbidden : 서바가 요청을 이해했지만 승인을 거부함
2. 404 Not Found : 요청 리소스가 서버에 없음 or 해당 리소스를 숨기고 싶을 때
<br><br>

**5xx : Server Error**
: 서버 문제로 오류 발생 → 서버가 문제이기에 재시도 시 성공 가능성 있음
<br><br>
1. 500 Internal Server Error : 서버 내부 문제로 오류 발생
2. 503 Service Unavailable : 서버가 일시적 과부하 또는 예정된 작업으로 잠시 요청 처리 못함

** 진짜 서버에 큰 문제가 생겼을 때 나와야 하는 오류
<br><br>

# 캐시와 조건부 요청

**캐시 기본 동작**
<br><br>
캐시가 적용되지 않을 경우 만약 보고 싶은 사이트에 이미지 파일이 있다면 이 페이지를 매번 요청할 때마다 이 이미지를 다운받아야 한다. 이처럼 캐시가 적용되지 않을 경우 데이터가 변경되지 않아도 계속 네트워크를 통해 다운이 필요하고 인터넷 네트워크는 비싸고 매우 느리기 때문에 브라우저 로딩 속도가 느려지며 결국 나쁜 사용자 경험을 제공하게 된다. 캐시가 적용되면 네트워크를 통해 다시 받을 필요없이 처음 요청 시 캐시 저장소에 저장된 응답 데이터를 다시 사용하면 된다. 이 때 캐시에서는 유효 기간이 주어지게 되는데 이 유효 시간이 경과할 경우 다시 네트워크를 통해서 이미지 다운이 필요하다. 좀 더 효율적인 방법이 없을까?
<br><br>

**검증 헤더와 조건부 요청**
<br><br>
캐시 유효 시간이 초과되어도 만약 서버의 데이터와 캐시 데이터가 다르지 않다면 캐시를 재사용하는 것이 효율적이다. 그러므로 처음 응답 데이터를 보낼 때 Last-Modified 란 이름으로 최종 변경 일자를 헤더에 넣어 보낸다. 캐시는 이 데이터를 가지고 있다가 캐시 유효 시간 초과 후 다시 요청할 때 If Modified Since 라는 태그에 이 최종 변경 일자를 넣어 보낸다. 서버가 이를 확인하고 만약 최종 변경 일자가 바뀌었다면 다시 응답 body 데이터를 넣어 보내고 만약 변경되지 않았다면 304 상태 코드를 보내며 body 데이터를 뺀 응답 헤더 데이터만 클라이언트에 보내고 클라이언트는 캐시 데이터를 재사용한다. 이를 통해 네트워크 다운로드 없이 효율적인 응답을 할 수 있다.

Last-Modifed - If Modified Since 말고 Etag 를 사용하는 If-None-Match 방식도 있다. 최종 변경 일자를 사용하는 방법은 수정 후 되돌려서 데이터 결과는 바뀐 게 없는데 변경 일자만 갱신된 경우나 조금의 변경은 그냥 무시하게 다른 곳에서 관리하고 싶을 경우에는 적합하지 않을 수 있다. Etag 방식은 캐시용 데이터에 임의의 고유한 버전 이름을 명명해서 데이터가 바뀌면 이 값이 바뀌도록 하고 요청을 보낼 때 Etag 값을 보내서 원 서버의 Etag 값이 바뀌었으면 200 OK를 보내고, 바뀌지 않았으면 304 Not Modified를 보내 캐시를 재사용하도록 할 수 있다. 캐시 제어 로직을 서버에서만 온전히 관리하는 것이 특징이다.
